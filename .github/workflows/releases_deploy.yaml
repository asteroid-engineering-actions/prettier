name: release-deploy
on:
  push:
    branches:
      - main
  workflow_dispatch:
jobs:
  build_push_docker:
    name: Publish Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    steps:
      - uses: actions/checkout@v3
      - name: Get Action Version
        id: get-metadata
        run: |
          VERSION=$(./dist/ae_prettier_action_linux_amd64 -version)

          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          VERSION="${VERSION#[vV]}"

          Mmp="${VERSION%+*}"
          Mmp="${Mmp%-*}"

          IFS=$'.'
          read -r -a Mmp <<< "$Mmp"
          IFS=$'\n\t'

          VERSION_MAJOR="${Mmp[0]}"
          VERSION_MINOR="${Mmp[1]:-x}"
          VERSION_PATCH="${Mmp[2]:-x}"

          VERSION_PRERELEASE="${VERSION#*-}"

          if [[ "$VERSION" == "$VERSION_PRERELEASE" ]];
          then
              VERSION_PRERELEASE=""
          else
              VERSION_PRERELEASE="${VERSION_PRERELEASE%+*}"
          fi

          BUILD_METADATA="${VERSION#*+}"

          if [[ "$BUILD_METADATA" == "$VERSION" ]];
          then
              BUILD_METADATA=""
          fi

          echo "Version Major: $VERSION_MAJOR"
          echo "VERSION_MAJOR=$VERSION_MAJOR" >> $GITHUB_OUTPUT

          echo "Version Minor: $VERSION_MINOR"
          echo "VERSION_MINOR=$VERSION_MINOR" >> $GITHUB_OUTPUT

          echo "Version Patch: $VERSION_PATCH"
          echo "VERSION_PATCH=$VERSION_PATCH" >> $GITHUB_OUTPUT

          echo "Version PreRelease: $VERSION_PRERELEASE"
          echo "VERSION_PRERELEASE=$VERSION_PRERELEASE" >> $GITHUB_OUTPUT

          echo "Build Metadata: $BUILD_METADATA"
          echo "BUILD_METADATA=$BUILD_METADATA" >> $GITHUB_OUTPUT
      - name: Add and Update Git Tags
        id: add-update-tags
        uses: actions/github-script@v6
        env:
          AE_VERSION_MAJOR: '${{ steps.get-metadata.outputs.VERSION_MAJOR }}'
          AE_VERSION_MINOR: '${{ steps.get-metadata.outputs.VERSION_MINOR }}'
          AE_VERSION_PATCH: '${{ steps.get-metadata.outputs.VERSION_PATCH }}'
          AE_VERSION_PRERELEASE: '${{ steps.get-metadata.outputs.VERSION_PRERELEASE }}'
          AE_BUILD_METADATA: '${{ steps.get-metadata.outputs.BUILD_METADATA }}'
        with:
          script: |
            const {
              AE_VERSION_MAJOR: versionMajor,
              AE_VERSION_MINOR: versionMinor,
              AE_VERSION_PATCH: versionPatch,
              AE_VERSION_PRERELEASE: versionPreRelease,
              AE_BUILD_METADATA: buildMetadata,
            } = process.env;

            const rtrn = {};

            rtrn.isPreRelease = '' !== versionPreRelease;
            rtrn.hasBuildMetadata = '' !== buildMetadata;
            rtrn.version = `${versionMajor}.${versionMinor}.${versionPatch}${rtrn.isPreRelease ? '-' : ''}${versionPreRelease}${rtrn.hasBuildMetadata ? '+' : ''}${buildMetadata}`;
            rtrn.semanticVersion = {
              major: versionMajor,
              minor: versionMinor,
              patch: versionPatch,
              preRelease: versionPreRelease,
              buildMetadata,
            };

            console.log('############################################');
            console.log(`# Build Version: v${rtrn.version}`);
            console.log('############################################');

            if (rtrn.isPreRelease) {
              console.log('############################################');
              console.log('# Is PreRelease, only adding vM.m.p-P tag');
              console.log('############################################');
              return JSON.stringify(rtrn);
            }

            console.log('############################################');
            console.log('# Not PrRelease, adding vM, vM.m, vM.m.p tags');
            console.log('############################################');

            rtrn.versionGitRefs = [
              {
                name: 'Full Semantic Version Tag',
                refString: `tags/v${rtrn.version}`,
                currentGithubRef: undefined,
              },
              {
                name: 'Major, Minor, Patch Tag',
                refString: `tags/v${rtrn.semanticVersion.major}.${rtrn.semanticVersion.minor}.${rtrn.semanticVersion.patch}`,
                currentGithubRef: undefined,
              },
              {
                name: 'Major, Minor Tag',
                refString: `tags/v${rtrn.semanticVersion.major}.${rtrn.semanticVersion.minor}`,
                currentGithubRef: undefined,
              },
              {
                name: 'Major Tag',
                refString: `tags/v${rtrn.semanticVersion.major}`,
                currentGithubRef: undefined,
              }
            ];

            for (const versionGitRef of rtrn.versionGitRefs) {
              versionGitRef.currentGithubRef = await getCurrentRef(versionGitRef.refString);

              console.log(versionGitRef);
            }



            console.log('############################################');
            console.log('# Script Result');
            console.log('############################################');

            console.log(JSON.stringify(rtrn, null, 2));

            async function getCurrentRef(refString) {
              console.log(`Input refString ${refString}`);

              for await (const refs of github.paginate.iterator(github.rest.git.listMatchingRefs, {
                ...context.repo,
                ref: refString,
              })) {
                console.log(refs.data);
                const githubRefs = refs.data.filter((r) => r.ref === `refs/${refString}`);
                console.log(githubRefs);

                if (githubRefs.length > 0) {
                  return githubRefs[0];
                }
              }

              return undefined;
            }
